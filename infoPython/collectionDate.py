
#                         Списки(list) - или массив в простонародье
'''
Массивов в классическом понимании в Python нет,
но есть списки, которые выполняют аналогичную функцию — упорядоченную коллекцию элементов.
'''

# создание списка
fruits = ["яблоко", "банан", "вишня"]

# добавление в список
fruits = ["яблоко", "банан", "вишня"]
fruits.append("апельсин")
print(fruits) #["яблоко", "банан", "вишня", "апельсин"]

# удаление из списка
fruits = ["яблоко", "банан", "вишня"]
fruits.remove("банан")
print(fruits) #["яблоко", "вишня"]

# доступ к элементу по списку
fruits = ["яблоко", "банан", "вишня"]
print(fruits[0])  # Выведет: яблоко

# доступ к элементу по срезу индекса
fruits = ["яблоко", "банан", "вишня"]
print(fruits[0:1])  # Выведет: яблоко
print(fruits[0:2])  # Выведет: яблоко, банан
print(fruits[0:3])  # Выведет: яблоко, банан, вишня

# изменение элемента
fruits = ["яблоко", "банан", "вишня"]
fruits[2] = "груша"
print(fruits)  #["яблоко", "банан", "груша"]

# узнаем длину списка
fruits = ["яблоко", "банан", "вишня"]
len_list = len(fruits)
print(len_list) # выведет 3

  # можно сделать проще - сразу передав len(list) в виде аргумента в функцию print()
  print(len(fruits))

# Списки в python могут содержать в себе различные типы данных:
mixed_list = ["Алиса", 30, 1.75, True, [1, 2, 3], {"key": "value"}, (4, 5, 6)]

print(mixed_list)  # Выведет ['Алиса', 30, 1.75, True, [1, 2, 3], {'key': 'value'}, (4, 5, 6)]


#                        Словари (dict)
'''
Словарь в Python — это неупорядоченная коллекция элементов,
где каждый элемент хранится как пара ключ-значение.
'''

# создание слооваря
person = {"имя": "Алиса", "возраст": 30}

# добавление или изменение элемента
person["город"] = "Москва"

# удаление элемента
del person["возраст"]

# доступ к элементу по ключу
print(person["имя"])  # Выведет: Алиса

# проверка наличия ключа
print("город" in person)  # Выведет: True

# словари внутри словаря
person = {
    "имя": "Алиса",
    "возраст": 30,
    "адрес": {
        "город": "Москва",
        "улица": "Тверская"
    }
}

# Доступ к данным во вложенном словаре
print(person["адрес"]["город"])

# списки внутри словаря
person = {
    "имя": "Алиса",
    "возраст": 30,
    "хобби": ["путешествия", "фотография", "чтение"]
}

# Доступ к элементу списка внутри словаря
print(person["хобби"][1])  # Выведет: фотография


# Переменные как значения в словаре
name = "Алиса"
age = 30

person = {
    "имя": name,
    "возраст": age
}

print(person["имя"])  # Выведет: Алиса
print(person["возраст"])  # Выведет: 30

# Добавление и изменение элементов
person["хобби"].append("рисование")
print(person["хобби"])  # Выведет: ['путешествия', 'фотография', 'чтение', 'рисование']

person["адрес"]["город"] = "Санкт-Петербург"
print(person["адрес"]["город"])  # Выведет: Санкт-Петербург

# Удаление элементов
person["хобби"].remove("чтение")
print(person["хобби"])  # Выведет: ['путешествия', 'фотография', 'рисование']

person["хобби"].remove("чтение")
print(person["хобби"])  # Выведет: ['путешествия', 'фотография', 'рисование']

del person["возраст"]
print(person)  # Выведет словарь без пары "возраст"

'''
.copy() - метод создаст новый объект в новой ячейки памяти,
и тогда каждая ссылка будет ссылаться на разные id в ячейках памяти:
'''

original = [5, 4, 3]
copy_from_original = original.copy()

copy_from_original.append(6)

print("наш первый список", original)  # Выведет: наш первый список [5, 4, 3]
print('список через метод .copy()', copy_from_original)  # Выведет: список через метод .copy() [5, 4, 3, 6]

print("id памяти для первого списка: ", id(original))  # id памяти для первого списка: 2133566731072
print("id памяти для скопированного списка: ", id(copy_from_original))  # id памяти для скопированного списка: 2133566694464



#                Кортежи(tuple)
'''
Кортеж — это неизменяемая упорядоченная коллекция элементов.
Похож на список, но не позволяет изменять элементы после создания.
'''

# Создание кортежа
coordinates = (10, 20, 30)

# Доступ к элементу по индексу
print(coordinates[1])  # Выведет: 20

# Важно: кортежи не поддерживают изменение элементов, попытка это сделать вызовет ошибку

